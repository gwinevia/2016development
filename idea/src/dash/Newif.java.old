package dash;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.tree.*;
import javax.swing.border.*;
import java.awt.*;
import java.io.*;
import java.util.*;
import java.awt.event.*;
import java.awt.datatransfer.*;

class Newif extends JFrame implements ActionListener {

  /** DVM */
  private DVM dvm;

  /** エラーを表示する部品 */
  private JTextArea errorLogArea;
  private JScrollPane errorScrollPane;

  /** 全てのログを表示する部品 */
  private JTextArea logArea;
  private JScrollPane logScrollPane;

  /** ACLエディタ */
  private AclPanel aclPanel;

  /** ACLエディタへのメッセージを表示する部品 */
  private JTextArea receiveArea;
  
  /** メッセージの内容を表示する部品 */
  private JTextArea msgArea;
  
  /** タブ */
  private JTabbedPane logTabbedPane;

  /** エージェントを表すもの */
  private DashTree treePane;

  /** ルートノード */
  private DefaultMutableTreeNode rootnode;

  /** 名前とノードの対応。ACLエディタは含まれない。 */
  private Hashtable nodetable;

  /** 環境ノードを格納するテーブル */
  private Hashtable envtable;

  /** リポジトリ型DVMならtrue */
  private boolean isRtype;

  /** ACLエディタノードとパス */
  private DefaultMutableTreeNode aclnode;
  private static final String ACL_NODE_NAME = DashMessage.IF;

  /** ポップアップ */
  private JPopupMenu treePopupMenu;

  /** フレーム */
  private JFrame ifFrame;
  private JSplitPane split;

  /** アクション */
  private SendAction sendAction = new SendAction("Send", null);
  private InspectAction inspectAction = new InspectAction("Inspect", null);
  private CutAction cutAction = new CutAction("Cut", null);
  private CopyAction copyAction = new CopyAction("Copy", null);
  private PasteAction pasteAction = new PasteAction("Paste", null);

  /** メモリ表示 */
  private JLabel memoryLabel;

  /** ステップボタンなど */
  private JCheckBox nonStopCheck;
  private JButton stepButton;

  /** インデント用スペース */
  private static String INDENT = "    ";

  /** 置き換えるオブジェクト。offの場合はnull。*/
  private static ConsoleReplace consoleReplace = null;

  /** 置き換えるオブジェクト。offの場合はfalse。*/
  private static boolean usingConsoleReplace = false;

  /** openするデフォルトのディレクトリ */
  private File defaultOpenDir;

  /** EditMenuを表示したときのFocusedObjectを保持するため(?)の変数 */
  private EditMenuListener editMenuListener;

  /** synchronized用オブジェクト */
  private String objectForSync = "s";

  /** settext用テーブル */
  private Hashtable textTable;

  /** コンストラクタ */
  Newif(String dvmname, DVM dvmparam, File msgfile, File dashdir) {
    super(dvmname);
    this.dvm = dvmparam;
    isRtype = dvm.isRtype();
    ifFrame = this;
    textTable = new Hashtable();
    
    File sdir = new File(dashdir, "scripts");
    if (sdir.exists())
      defaultOpenDir = sdir;
    else
      defaultOpenDir = dashdir;

    nodetable = new Hashtable();

    // Treeペイン
    rootnode = new DefaultMutableTreeNode("Root");
    DefaultMutableTreeNode node =new DefaultMutableTreeNode(dvmname);
    envtable = new Hashtable();
    envtable.put(dvmname, node);
    rootnode.add(node);
    aclnode = new DefaultMutableTreeNode(ACL_NODE_NAME);
    node.add(aclnode);
    treePane = new DashTree(rootnode);
    treePane.setRootVisible(false);
    treePane.setCellRenderer(new DashRenderer());
    JScrollPane treeScrollPane = new JScrollPane(treePane);
    treeScrollPane.setBorder(new TitledBorder("Env. & Agent"));
    // Treeペインのアクション
    treePane.addMouseListener(new TreeSelect());
    treePopupMenu = new JPopupMenu("Tree");
    treePopupMenu.add(inspectAction);
    treePopupMenu.add(sendAction);
    treePopupMenu.addSeparator();
    treePopupMenu.add(copyAction);
    // Treeを開く
    DefaultTreeModel treeModel = (DefaultTreeModel)treePane.getModel();
    TreeNode nodes[] = treeModel.getPathToRoot(node);
    TreePath path = new TreePath(nodes);
    treePane.expandPath(path);

    // logタブ
    logArea = new JTextArea(""); //(dvmname="+dvmname+")\n");
    logArea.setLineWrap(true);
    logScrollPane = new JScrollPane(logArea);

    // errorタブ
    errorLogArea = new JTextArea();
    errorLogArea.setLineWrap(true);
    errorScrollPane = new JScrollPane(errorLogArea);

    // acl-editorタブ
    String options[] = { "Send" };
    aclPanel = new AclPanel(options, null, this);
    aclPanel.setContArea("()");
    JScrollPane aclScrollPane = new JScrollPane(aclPanel);

    // receiveタブ
    receiveArea = new JTextArea();
    receiveArea.setLineWrap(true);
    JScrollPane receiveScrollPane = new JScrollPane(receiveArea);

    // msgタブ
    msgArea = new JTextArea();
    msgArea.setLineWrap(true);
    JScrollPane msgScrollPane = new JScrollPane(msgArea);

    // タブ張り付け
    logTabbedPane = new JTabbedPane(JTabbedPane.TOP);
    logTabbedPane.addTab("log", logScrollPane);
    logTabbedPane.addTab("error", errorScrollPane);
    logTabbedPane.addTab("acl-editor", aclScrollPane);
    logTabbedPane.addTab("receive", receiveScrollPane);
    logTabbedPane.addTab("msg", msgScrollPane);

    // メニューバー
    JMenuBar menubar = new JMenuBar();
    JMenu fileMenu = new JMenu("File");
    fileMenu.add(menuItem("Open"));
    fileMenu.add(menuItem("Quit"));
    menubar.add(fileMenu);
    JMenu editMenu = new JMenu("Edit");
    editMenu.add(cutAction);
    editMenu.add(copyAction);
    editMenu.add(pasteAction);
    editMenuListener = new EditMenuListener();
    editMenu.addMenuListener(editMenuListener);
    menubar.add(editMenu);
    JMenu agentMenu = new JMenu("Agent");
    agentMenu.add(inspectAction);
    agentMenu.add(sendAction);
    agentMenu.addSeparator();
    agentMenu.add(menuItem("Kill"));
    agentMenu.addSeparator();
    agentMenu.add(menuItem("info"));
    agentMenu.add(menuItem("log"));
    agentMenu.addMenuListener(new AgentMenuListener());
    menubar.add(agentMenu);
    JMenu sysMenu = new JMenu("System");
    sysMenu.add(menuItem("Memory"));
    sysMenu.addSeparator();
    sysMenu.add(menuItem("Threads"));
    sysMenu.add(menuItem("All threads"));
    sysMenu.add(menuItem("RMI lookup"));
    menubar.add(sysMenu);
    /* cout
    if (msgfile != null)
      menubar.add(makeMessageMenu(msgfile));
    */
    setJMenuBar(menubar);

    // ツールバー
    JToolBar toolbar = new JToolBar();
    
    nonStopCheck = new JCheckBox(getImageIcon("resources/pause.gif"));
    nonStopCheck.setSelectedIcon(getImageIcon("resources/nonstop.gif"));
    nonStopCheck.setSelected(false); // ステップ動作
    nonStopCheck.setHorizontalAlignment(SwingConstants.CENTER);
    nonStopCheck.setFocusPainted(false);
    nonStopCheck.setBorderPainted(true);
    nonStopCheck.setMargin(new Insets(0,0,1,0));
    toolbar.add(nonStopCheck);

    stepButton = new JButton(getImageIcon("resources/step.gif"));
    stepButton.setEnabled(false);      // 押下不可能
    nonStopCheck.setHorizontalAlignment(SwingConstants.CENTER);
    stepButton.setBorder(BorderFactory.createRaisedBevelBorder());
    stepButton.setFocusPainted(false);
    toolbar.add(stepButton);

    CheckBoxListener listener = new CheckBoxListener();
    nonStopCheck.addItemListener(listener);    
    stepButton.addActionListener(listener);

    memoryLabel = new JLabel("? / ? Kb");

    JPanel panel = new JPanel();
    panel.setLayout(new BorderLayout());
    panel.add(treeScrollPane, BorderLayout.CENTER);
    panel.add(memoryLabel, BorderLayout.SOUTH);

    split = new JSplitPane(JSplitPane.VERTICAL_SPLIT, true, panel, logTabbedPane);
    if (isRtype)
      split.setDividerLocation(200);
    else
      split.setDividerLocation(150);

    Container container = this.getContentPane();
    container.add(split, BorderLayout.CENTER);
    container.add(toolbar, BorderLayout.NORTH);

    addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent evt) {
          dvm.finalizeDVM();
        }});

    setSize(300,400);
  }

  private JMenuItem menuItem(String label) {
    JMenuItem item = new JMenuItem(label);
    item.addActionListener(this);
    return item;
  }

  /** Messageメニューを付ける。*/
  /*
  public void addMessageMenu(final File msgfile) {
    SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          getJMenuBar().add(makeMessageMenu(msgfile));
          getJMenuBar().revalidate();
        }
      });
  }
  */

  /** ワークプレースのNewifのみが持つメニューを作成する。*/
  /* cout
  private JMenu makeMessageMenu(File msgfile) {
    JMenu menu = new JMenu("Message");

    // よみこみ
    StringBuffer buffer = new StringBuffer();
    try {
      BufferedReader br = new BufferedReader(new FileReader(msgfile));
      while (br.ready()) {
        String line = br.readLine();
        if (line != null)
          buffer.append(line + "\n");
      }
    } catch (FileNotFoundException e) {
      JMenuItem item = new JMenuItem("messages.txt not found");
      menu.add(item).setEnabled(false);
      return menu;
    } catch (IOException e) {
      e.printStackTrace();
      JMenuItem item = new JMenuItem("IOException occured.");
      menu.add(item).setEnabled(false);
      return menu;
    }
    replaceMeta(buffer);

    // ぱーず
    ps.Parser parser = new ps.Parser("messages.txt", buffer.toString(), false);
    Vector lists = null;
    try {
      lists = parser.parseMessages();
    } catch (ps.SyntaxException e) {
      System.err.println(e);
    }

    if (lists == null)
      return menu;

    // メニュー作成
    MessageAction msgAct = new MessageAction();
    for (Enumeration e = lists.elements(); e.hasMoreElements(); ) {
      String item = (String)e.nextElement();
      JMenu menuItem = new JMenu(item);
      Vector subItems = (Vector)e.nextElement();
      for (Enumeration ee = subItems.elements(); ee.hasMoreElements(); ) {
        Hashtable hash = (Hashtable)ee.nextElement();
        String subItem = (String)hash.get("submenu");
        JMenuItem subMenuItem = new JMenuItem(subItem);
        subMenuItem.addActionListener(msgAct);
        menuItem.add(subMenuItem);
        String actionCommand = item+"."+subItem;
        subMenuItem.setActionCommand(actionCommand);
        msgAct.putHash(actionCommand, hash);
      }
      menu.add(menuItem);
    }

    return menu;
  }
  */

  /** "<?Repository>"などを置き換える。*/
  private void replaceMeta(StringBuffer buffer) {
    replaceMeta(buffer,
                "\"<?Repository>\"",
                System.getProperty("adips97.w.defaultR"));
      
    replaceMeta(buffer,
                "\"<?Here>\"",
                dvm.getDVMname());
  }

  private void replaceMeta(StringBuffer buffer, String oldstr, String newstr) {
    int length = oldstr.length();
    while (true) {
      int start = buffer.toString().indexOf(oldstr);
      if (start < 0)
        break;
      buffer.replace(start, start+length, newstr);
    }
  }

  /** ImageIconを返す。*/
  private ImageIcon getImageIcon(String path) {
    java.net.URL url = this.getClass().getResource(path);
    return new ImageIcon(url);
  }

  /** メモリの監視を開始する */
  void startMemoryWatch() {
    Runnable r = new Runnable() {
        Runtime runtime = Runtime.getRuntime();
        long total, free, use;
        
        public void run() {
          replaceConsole();
          if (usingConsoleReplace)
            while (consoleReplace==null)
	      try { Thread.sleep(500); } catch (InterruptedException e) { }
            
          while (true) {
            if (usingConsoleReplace)
              consoleReplace.print();
            total = runtime.totalMemory() / 1024L;
            free = runtime.freeMemory() / 1024L;
            use = total - free;
            memoryLabel.setText("use: "+use+ " Kb    total: "+total+" Kb");
            try { Thread.sleep(1000); } catch (InterruptedException e) { }
          }
        }
      };
    Thread thread = new Thread(dvm.dashThreads, r, "MemoryWatcher");
    thread.start();
    while (usingConsoleReplace && consoleReplace==null)
      try { Thread.sleep(500); } catch (InterruptedException e) { }
  }


  /** nonStopCheckを押した状態(nonstop状態)にする */
  void setNonstop() {
    SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          if (!nonStopCheck.isSelected()) {
            nonStopCheck.doClick();
          }}});
  }

  /**
   * エージェントを環境に追加する。次の場合に呼ばれる。
   * 1)リポジトリエージェントがファイルから生成されたとき
   * 2)インスタンスエージェントが生成されたとき
   * 
   * @param name エージェント名
   */
  void addAgent(final String name) {
    // 追加する。
    DefaultMutableTreeNode agnode = new DefaultMutableTreeNode(name);
    final DefaultMutableTreeNode envnode =
        (DefaultMutableTreeNode)envtable.get(dvm.getDVMname());
    envnode.add(agnode);
    nodetable.put(name, agnode);
    Runnable r = new Runnable() {
        public void run() {
          DefaultTreeModel treeModel = (DefaultTreeModel)treePane.getModel();
          treeModel.nodeStructureChanged(rootnode);

          // 見せる。
          TreeNode nodes[] = treeModel.getPathToRoot(envnode);
          TreePath path = new TreePath(nodes);
          treePane.expandPath(path);
        }
      };
    SwingUtilities.invokeLater(r);
  }

  /** エージェントを消す */
  void removeAgent(final String name) {
    textTable.remove(name);
    Runnable r = new Runnable() {
        public void run() {
          // 消す。
          DefaultMutableTreeNode agnode =
            (DefaultMutableTreeNode)nodetable.get(name);
          DefaultMutableTreeNode parent =
            (DefaultMutableTreeNode)agnode.getParent();
          parent.remove(agnode);
          nodetable.remove(name);

          DefaultTreeModel treeModel = (DefaultTreeModel)treePane.getModel();
          treeModel.nodeStructureChanged(rootnode);

          // 見せる。
          TreeNode nodes[] = treeModel.getPathToRoot(parent);
          TreePath path = new TreePath(nodes);
          treePane.expandPath(path);
        }
      };
    SwingUtilities.invokeLater(r);
  }

  /**
   * メッセージの処理を行う。
   */
  public void showMsg(DashMessage m) {
    synchronized (objectForSync) {
      showMessage(m);
    }
  }

  /**
   * メッセージの処理を行う。
   */
  private void showMessage(final DashMessage m) {
    // specify_managerなら、木を作る。
    if (m.isSpecifyManager()) {
      Runnable r = new Runnable() {
          public void run() {
            // 対象
            DefaultMutableTreeNode manager =
              (DefaultMutableTreeNode)nodetable.get(m.from);
            DefaultMutableTreeNode contractor =
              (DefaultMutableTreeNode)nodetable.get(m.to);

            // 付け替える
            manager.add(contractor);

            DefaultTreeModel treeModel = (DefaultTreeModel)treePane.getModel();
            treeModel.nodeStructureChanged(rootnode);

            // 見せる。
            TreeNode nodes[] = treeModel.getPathToRoot(manager);
            TreePath path = new TreePath(nodes);
            treePane.expandPath(path);
          }
        };
      SwingUtilities.invokeLater(r);
    } else {
      Runnable r = new Runnable() {
          public void run() {
            msgArea.setText(m.toString2());
          }};
      SwingUtilities.invokeLater(r);
      treePane.showMsg(m, dvm.getFullname());
    }
  }

  public void actionPerformed(ActionEvent e) {
    String command = e.getActionCommand();
    if (e.getSource() instanceof JButton && command.equals("Send"))
      sendMessageFromACLeditor();
    else if (command.equals("Open"))
        openAgentfile();
    else if (command.equals("Quit"))
      dvm.finalizeDVM();
    else if (command.equals("Kill"))
      killAgent();
    else if (command.equals("Memory"))
      printMemory();
    else if (command.equals("Threads"))
      printThreads(false);
    else if (command.equals("All threads"))
      //dumpThreads(Thread.currentThread().getThreadGroup());
      printThreads(true);
    else if (command.equals("RMI lookup"))
      printRMIlookup();
    /* cout
    else if (command.equals("info"))
      printAgentInfo();
    else if (command.equals("log"))
      printAgentLog();
    */
  }

  /** ACLエディタに入力されたメッセージを送信する */
  private void sendMessageFromACLeditor() {
    String performative = aclPanel.getPerfField();
    String to = aclPanel.getToField();
    String content = aclPanel.getContArea();

    if (performative.equals("") || to.equals("") || content.equals("")) {
      printlnE("[エラー]: acl-editorに入力していない欄があります。");
      return;
    }

    if (!content.startsWith("(") || !content.endsWith(")")) {
      printlnE("[エラー]: acl-editorの:contentの入力が、\"(\"で始まっていないか、\")\"で終っていません。");
      return;
    }

    if (to.equals(DashMessage.IF)) {
      printlnE("[エラー]: 「_interface@環境名」ならOK。");
      return;
    }

    // 両端の( )を取り除く(TAFとの互換性のため)→2.0では取り除かない。
    /*
    int length = content.length();
    content = content.substring(1,length-1);
    */

    // toに@が付いているなら、arrivalを設定する。
    String arrival = null;
    int p = to.indexOf('@');
    int q = to.lastIndexOf('@');
    if (p>0)
      if (p==q) {
        arrival = to.substring(p+1);
        to = to.substring(0, p);
        if (arrival.equals("") || to.equals("")) {
          printlnE("[エラー]: acl-editorの :toの値が不正です。");
          return;
        }
      } else {
        printlnE("[エラー]: acl-editorの :toの値が不正です(複数の@)。");
        return;
      }

    try {
      // Createrのキューに入れる。
      dvm.sendMessageFromUser(null, performative, null, to, arrival, content, null);
    } catch (DashException e) {
      printlnE("[エラー]: ACLエディタに入力した:contentの値が不正です。");
    }

  }

  /** エージェントを終了させる。
      releaseの処理については、CM_J.finalizeInstAg()参照！*/
  private void killAgent() {
    TreePath path = treePane.getSelectionPath();
    if (path == null) return; //念のため

    String name = path.getLastPathComponent().toString();
    Object[] msg = { "Kill "+name+". OK?" };
    int ans = JOptionPane.showConfirmDialog(getContentPane(), msg, "Confirm Dialog", JOptionPane.OK_CANCEL_OPTION);

    if (ans==JOptionPane.OK_OPTION)
      dvm.stopAgent(name);
  }

  /**
   * エージェント記述ファイルを開く。
   */
  private void openAgentfile() {
    JFileChooser fileChooser = new JFileChooser(defaultOpenDir);
    fileChooser.addChoosableFileFilter(new DashFileFilter());
    int ret = fileChooser.showOpenDialog(getContentPane());
    File file = fileChooser.getSelectedFile();
    if (ret!=JFileChooser.APPROVE_OPTION || file==null)
      return;
    dvm.addLoadQueue(file);
  }

  /** ファイルフィルタ */
  class DashFileFilter extends javax.swing.filechooser.FileFilter {

    public boolean accept(File file) {
      if (file.isDirectory())
        return true;
      boolean accepted =false;
      String filename = file.getName().toLowerCase();
      if (filename.endsWith(".dash"))
        accepted = true;
      return accepted;
    }

    public String getDescription() {
      return "Dash Files (*.dash)";
    }
  }
      

  /** メモリに関する情報を表示する */
  private void printMemory() {
    Runtime runtime = Runtime.getRuntime();
    long total = runtime.totalMemory();
    long free = runtime.freeMemory();
    println("[Memory]");
    println("total: "+total/1024+"Kb\n"+
            "use: "+(total - free)/1024+"Kb\n"+
            "free: "+free/1024+"Kb\n");

  }

  /** VM上の全てのスレッドを標準出力に表示する。
      http://java-house.etl.go.jp/ml/archive/j-h-b/001346.html#bodyより。*/
  private void dumpThreads(ThreadGroup tg) {
    ThreadGroup parent = tg.getParent();
    if (parent != null)
      dumpThreads(parent);
    else { // reached the top
      if (tg != null) {
        System.out.println("Dumping Thread");
        tg.list();
      }
    }
  }

  /** DASHで起動した全てのスレッドを表示する */
  private void printThreads(boolean allSystem) {
    // まずtopあるいはmainまで遡る
    ThreadGroup root = dvm.dashThreads;
    if (allSystem)
      while (root.getParent()!=null) root = root.getParent();
    else
      while (!root.getName().equals("main")) root = root.getParent();

    //降りて行く。
    Hashtable hash = getThreadHash(root);

    // 表示
    int i = logTabbedPane.indexOfTab("log");
    logTabbedPane.setSelectedIndex(i);
    if (allSystem)
      println("[All threads]");
    else
      println("[Threads]");
    println(printThreadsHash(hash, 0));
  }

  private String printThreadsHash(Hashtable hash, int level) {
    String space = "";
    for (int i=0; i<level; i++)
      space += INDENT;

    StringBuffer buf = new StringBuffer();
    for (Enumeration e = hash.keys(); e.hasMoreElements(); ) {
      Object groupname = e.nextElement();
      buf.append(space).append(groupname).append(" {\n");

      Vector value = (Vector)hash.get(groupname);
      level+=1;
      for (Enumeration ee = value.elements(); ee.hasMoreElements(); ) {
        Object o = ee.nextElement();
        if (o instanceof Hashtable) {
          buf.append(printThreadsHash((Hashtable)o, level));
        } else
          buf.append(space).append(INDENT).append(o).append('\n');
      }
      buf.append(space).append("}\n");
    }
    return buf.toString();
  }

  private Hashtable getThreadHash(ThreadGroup root) {
    Vector vector = new Vector();

    // まずスレッド
    Thread[] threads = new Thread[root.activeCount()];
    root.enumerate(threads, false);
    for (int i=0; i<threads.length; i++)
      if (threads[i] != null)
        vector.add(threads[i].getName()); // .getName()を消すと詳細になる。

    // 次にグループ
    ThreadGroup[] groups = new ThreadGroup[root.activeGroupCount()];
    root.enumerate(groups, false);
    for (int i=0; i<groups.length; i++)
      if (groups[i] != null)
        vector.add(getThreadHash(groups[i]));

    Hashtable hash = new Hashtable();
    hash.put(root.getName(), vector); // .getName()を消すと詳細になる。
    return hash;
  }

  /**
   * このホストで起動されているRMIレジストリに登録されている名前を表示する。
   */
  private void printRMIlookup() {
    if (!dvm.usingRmiModule) {
      println("[RMI lookup]\nRMI is not used.");
      return;
    }

    try {
      String[] url = java.rmi.Naming.list("rmi://localhost/");
      println("[RMI lookup]");
      for (int i=0; i<url.length; i++)
        println(url[i]);
    } catch (Exception e) {
      printlnE("[RMI lookup]", e);
    }
  }

  /** 旧インスペクタのコマンド */
  /* cout
  private void printAgentInfo() {
    TreePath path = treePane.getSelectionPath();
    if (path != null) { // 念のため
      String receiver = path.getLastPathComponent().toString();
      adips97.dkset_J.CM_J cm =
        (adips97.dkset_J.CM_J)environment.agTable.get(receiver);
      if (cm == null)
        println("no such agent.\n");
      else
        println(cm.getInfo()+"\n");
    }
  }
  */

  /** 旧インスペクタのコマンド */
  /* cout
  private void printAgentLog() {
    TreePath path = treePane.getSelectionPath();
    if (path != null) { // 念のため
      String receiver = path.getLastPathComponent().toString();
      adips97.dkset_J.CM_J cm =
        (adips97.dkset_J.CM_J)environment.agTable.get(receiver);
      if (cm == null)
        println("no such agent.\n");
      else {
        String s = cm.getAllLog();
        println((s.length()>0) ? s : "no log.\n");
      }
    }    
  }
  */

  /** 受信したメッセージをreceiveタブに表示する。*/
  public void putMsg(DashMessage msg) {
    final String string;
    string = msg.toString2();
    if (isShowing()) {
      Runnable r = new Runnable() {
          public void run() {
            receiveArea.append(string+"\n\n");
            receiveArea.setCaretPosition(receiveArea.getText().length());
          }};
      SwingUtilities.invokeLater(r);
    } else
      System.out.println(string);
  }

  /** cout
  public void notifySendMsg(Message msg) {
    String arrival = (msg.arrival == null ? "" : " at "+msg.arrival);
    println("send "+msg.performative()+
            " to "+msg.to+arrival);
  }
  */


  /////////////////////////////////////////////////////////////////
  //  ログ関係  ///////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////

  
  /**
   * ログをログタブに表示する。
   * @param s ログ
   */
  void println(final String s) {
    if (isShowing()) {
      Runnable r = new Runnable() {
          public void run() {
            logArea.append(s+"\n");
            String text = logArea.getText();
            int l = text.length();
            if (l > 50000) {
              text = text.substring(30000);
              l = text.length();
              logArea.setText(text);
            }
            //logArea.setCaretPosition(logArea.getText().length());
            logArea.setCaretPosition(l);
          }
        };
      SwingUtilities.invokeLater(r);
    } else
      System.out.println(s);      
  }
   

  /**
   * エラーをエラータブに表示する。
   * @param s エラーの説明
   */
  void printlnE(final String s) {
    if (isShowing()) {
      Runnable r = new Runnable() {
          public void run() {
            errorLogArea.append(s+"\n");
            errorLogArea.setCaretPosition(errorLogArea.getText().length());
            int i = logTabbedPane.indexOfTab("error");
            logTabbedPane.setSelectedIndex(i);
          }
        };
      SwingUtilities.invokeLater(r);
    } else
      System.out.println(s);      
  }
   
  /**
   * 例外とその説明をエラータブに表示する。
   * @param s 説明
   * @param e 例外
   */
  void printlnE(String s, Exception e) {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    e.printStackTrace(pw);
    pw.flush();
    sw.flush();
    try { sw.close(); } catch (Exception ee) { ee.printStackTrace(); }
    printlnE(s+"\n"+sw.toString());
  }

  /** 木を表示のための内部クラス */
  class DashRenderer extends JLabel implements TreeCellRenderer {
    Color bgcolor =new DefaultTreeCellRenderer().getBackgroundSelectionColor();
    Icon openedIcon, closedIcon, aclIcon;
    public DashRenderer() {
      super();
      this.setFont(null);
      this.setForeground(Color.black);
      aclIcon = getImageIcon("resources/dashAcl.gif");
      if (isRtype) {
        openedIcon = getImageIcon("resources/dashRep.gif");
        closedIcon = getImageIcon("resources/dashRepClosed.gif");
      } else {
        openedIcon = getImageIcon("resources/dashWp.gif");
        closedIcon = getImageIcon("resources/dashWpClosed.gif");
      }
    }

    public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
      if (hasFocus) {
        setOpaque(true);
        setBackground(bgcolor);
      } else {
        setOpaque(false);
      }
      DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;

      if (node.getLevel()==1) {               // 環境
        if (expanded)
          this.setIcon(openedIcon);
        else
          this.setIcon(closedIcon);
      } else if (value == aclnode) {          // ACLエディタ
        this.setIcon(aclIcon);
      } else {                                // エージェント
        this.setIcon(null);
      }

      this.setText(node.toString());
      return this;
    }
  }

  /** settext */
  void settext(String agent, String s) {
    if (s.equals(""))
      textTable.remove(agent);
    else
      textTable.put(agent, s);

    Runnable r = new Runnable() { public void run() { treePane.repaint(); }};
    SwingUtilities.invokeLater(r);
  }

  /** Editメニューに関する内部クラス */
  class EditMenuListener implements MenuListener {
    Object focusedObj;

    public void menuCanceled(MenuEvent e) {}
    public void menuDeselected(MenuEvent e) {}
    public void menuSelected(MenuEvent e) {
      //Object focusedObj = ifFrame.getFocusOwner();
      focusedObj = ifFrame.getFocusOwner();
      
      if (focusedObj instanceof JTree) {
        cutAction.setEnabled(false);
        copyAction.setEnabled(treePane.getSelectionPath() != null);
        pasteAction.setEnabled(false);
      } else if (focusedObj instanceof JTextComponent) {
        boolean selected =((JTextComponent)focusedObj).getSelectedText()!=null;
        cutAction.setEnabled(selected);
        copyAction.setEnabled(selected);
        pasteAction.setEnabled(true);
      } else {
        cutAction.setEnabled(false);
        copyAction.setEnabled(false);
        pasteAction.setEnabled(false);
      }
    }
  }

  /** Agentメニューに関する内部クラス */
  class AgentMenuListener implements MenuListener {
    public void menuCanceled(MenuEvent e) {}
    public void menuDeselected(MenuEvent e) {}
    public void menuSelected(MenuEvent e) {
      Object focusedObj = ifFrame.getFocusOwner();

      boolean bool = false;
      TreePath path = treePane.getSelectionPath();
      if (focusedObj instanceof JTree && path!=null && 
          path.getPathCount()>2 && 
          !path.getLastPathComponent().equals(aclnode))
        bool = true;
      inspectAction.setEnabled(bool);
      sendAction.setEnabled(bool);
      JMenu menu = (JMenu)e.getSource();
      Component[] comps = menu.getMenuComponents();
      for (int i=0; i<comps.length; i++)
        if (comps[i] instanceof JMenuItem)
          ((JMenuItem)comps[i]).setEnabled(bool);
    }
  }

  /** 木のポップアップメニューに関する内部クラス */
  class TreeSelect extends MouseAdapter {

    /** Linux用 */
    public void mousePressed(MouseEvent e) {
      if (e.isPopupTrigger())
        showPopupMenu(e);
      else if ((e.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
        deselect(e);
    }

    /** Windows用 */
    public void mouseReleased(MouseEvent e) {
      if (e.isPopupTrigger())
        showPopupMenu(e);
      else if ((e.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
        deselect(e);
    }

    private void deselect(final MouseEvent e) {
      Runnable r = new Runnable() {
          public void run() {
            TreePath path = treePane.getPathForLocation(e.getX(), e.getY());
            if (path == null)
              treePane.clearSelection();
          }
        };
      SwingUtilities.invokeLater(r);
    }

    /** インスペクタの表示 */
    public void mouseClicked(MouseEvent e) {
      if (e.getClickCount() == 2) {
        TreePath path = treePane.getPathForLocation(e.getX(), e.getY());
        if (path != null && path.getPathCount() > 2 &&
            !path.getLastPathComponent().equals(aclnode)) {
          String receiver = path.getLastPathComponent().toString();
          dvm.openInspector(receiver);
        }
      }
    }

    /**
     * ポップアップメニューを開く。
     * エージェント名の上で開いた場合、そのエージェントを選択してから開く。
     */
    private void showPopupMenu(MouseEvent e) {
      JTree tree = (JTree)e.getComponent();
      final TreePath path = tree.getPathForLocation(e.getX(), e.getY());
      if (path != null) {
        Runnable r = new Runnable() {
            public void run() {
              treePane.setSelectionPath(path);
            }};
        SwingUtilities.invokeLater(r);
      }
      if (path != null || treePane.getSelectionPath() != null) {
        TreePath p = (path!=null) ? path : treePane.getSelectionPath();
        boolean bool = p.getPathCount() > 2 && !p.getLastPathComponent().equals(aclnode);
        inspectAction.setEnabled(bool);
        sendAction.setEnabled(bool);
        copyAction.setEnabled(true);
      } else {
        inspectAction.setEnabled(false);
        sendAction.setEnabled(false);
        copyAction.setEnabled(false);
      }
      treePopupMenu.show(e.getComponent(), e.getX(), e.getY());
    }

  }

  /** Sendアクション */
  class SendAction extends AbstractAction {
    public SendAction(String label, Icon icon) { super(label, icon); }
    /** ACLエディタを開く */
    public void actionPerformed(ActionEvent e) {
      Runnable r = new Runnable() {
          public void run() {
            TreePath path = treePane.getSelectionPath();
            if (path != null) { // 念のため
              String receiver = path.getLastPathComponent().toString();
              int i = logTabbedPane.indexOfTab("acl-editor");
              logTabbedPane.setSelectedIndex(i);
              aclPanel.setToField(receiver);
            }
          }};
      SwingUtilities.invokeLater(r);
    }
  }

  /** Inspectアクション */
  class InspectAction extends AbstractAction {
    public InspectAction(String label, Icon icon) { super(label, icon); }
    //インスペクタを開く
    public void actionPerformed(ActionEvent e) {
      TreePath path = treePane.getSelectionPath();
      if (path != null) { // 念のため
        String receiver = path.getLastPathComponent().toString();
        dvm.openInspector(receiver);
      }
    }
  }

  /** Cutアクション */
  class CutAction extends AbstractAction {
    public CutAction(String label, Icon icon) { super(label, icon); }
    public void actionPerformed(ActionEvent e) {
      Runnable r = new Runnable() {
          public void run() {
            //Object focusedObj = ifFrame.getFocusOwner();
            Object focusedObj = editMenuListener.focusedObj;
            if (focusedObj instanceof JTextComponent)
              ((JTextComponent)focusedObj).cut();
          }};
      SwingUtilities.invokeLater(r);
    }
  }

  /** Pasteアクション */
  class PasteAction extends AbstractAction {
    public PasteAction(String label, Icon icon) { super(label, icon); }
    public void actionPerformed(ActionEvent e) {
      Runnable r = new Runnable() {
          public void run() {
            //Object focusedObj = ifFrame.getFocusOwner();
            Object focusedObj = editMenuListener.focusedObj;
            if (focusedObj instanceof JTextComponent)
              ((JTextComponent)focusedObj).paste();
          }};
      SwingUtilities.invokeLater(r);
    }
  }

  /** Copyアクション */
  class CopyAction extends AbstractAction {
    public CopyAction(String label, Icon icon) { super(label, icon); }

    /**
     * システムクリップボードにコピーする。
     * JTreeが対象なら、選択されたエージェント名をコピーする。
     * JTextComponentが対象なら、テキストをコピーする。
     */
    public void actionPerformed(ActionEvent e) {
      Runnable r = new Runnable() {
          public void run() {
            //Object focusedObj = ifFrame.getFocusOwner();
            Object focusedObj = editMenuListener.focusedObj;
            if (focusedObj instanceof JTree) {
              TreePath path = ((JTree)focusedObj).getSelectionPath();
              if (path != null) { //念のため
                String receiver = path.getLastPathComponent().toString();
                StringSelection contents = new StringSelection(receiver);
                Clipboard clip =
                  Toolkit.getDefaultToolkit().getSystemClipboard();
                clip.setContents(contents, null);
              }
            } else if (focusedObj instanceof JTextComponent) {
              JTextComponent jtext = (JTextComponent)focusedObj;
              if (jtext.getSelectedText() != null)
                jtext.copy();
            }
          }            
        };
      SwingUtilities.invokeLater(r);
    }
  }

  /**
   * Messageメニューを選択したときに呼び出されるActionListener
   */
  class MessageAction implements ActionListener {

    /**
     * key   = メニューアイテム.サブメニューアイテム。
     * value = メッセージ
     */
    private Hashtable messageHash = new Hashtable();

    void putHash(String command, Hashtable hash) {
      messageHash.put(command, hash);
    }

    public void actionPerformed(ActionEvent e) {
      String command = e.getActionCommand();
      Hashtable hash = (Hashtable)messageHash.get(command);

      int i = logTabbedPane.indexOfTab("acl-editor");
      logTabbedPane.setSelectedIndex(i);

      String performative = (String)hash.get("performative");
      String to = (String)hash.get("to");
      String arrival = (String)hash.get("arrival");
      String content = (String)hash.get("content");

      if (arrival != null)
        to = to + "@" + arrival;
      aclPanel.setPerfField(performative);
      aclPanel.setToField(to);
      aclPanel.setContArea(content);
    }
  }

  /** チェックボックス/ボタン用 */
  class CheckBoxListener implements ItemListener, ActionListener {
    public void itemStateChanged(ItemEvent evt) {
      synchronized (stepButton) {
        if (evt.getStateChange() == ItemEvent.SELECTED)
          stepButton.notify();
      }
    }
    public void actionPerformed(ActionEvent evt) {
      synchronized (stepButton) {
        stepButton.notify();
      }
    }
  }

  /////////////////////////////////////////////////////////////////
  //  TreePane関係  ///////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////

  /**
   * メッセージを表示するJTree
   */
  class DashTree extends JTree {

    /** メッセージの方向を表す定数 */
    private final static int ERROR           =-1;
    private final static int NO_MESSAGE      = 0; // メッセージを表示しない
    private final static int AGENT_TO_AGENT  = 1;
    private final static int AGENT_TO_AGENTS = 2; // ブロードキャスト
    private final static int AGENT_TO_ENV    = 3; // 他の環境へ
    private final static int AGENT_TO_ACL    = 4; // 他の環境へ
    private final static int   ENV_TO_AGENT  = 5; // 他の環境から
    private final static int   ENV_TO_AGENTS = 6; // ブロードキャスト
    private final static int   ENV_TO_ACL    = 7;
    private final static int   ACL_TO_AGENT  = 8;
    private final static int   ACL_TO_AGENTS = 9;
    private final static int   ACL_TO_ENV    =10;
    private final static int   DVM_TO_DVM    =11; //DVMから他のDVMへ。
    
    /** メッセージの方向 */
    private int direction;

    /** 送信者エージェント */
    private String sender;

    /** 受信者エージェント */
    private String receiver;

    /** パフォーマティブ */
    private String performative;

    /** コンストラクタ */
    public DashTree(TreeNode root) {
      super(root);
      direction = NO_MESSAGE;
      sender = receiver = null;
      toggleClickCount = 3;
    }

    private void drawText(Graphics g) {
      for (Enumeration e = textTable.keys(); e.hasMoreElements(); ) {
        String name = (String)e.nextElement();
        String text = (String)textTable.get(name);
        TreePath path = getPathByName(name);
        Rectangle rect = getPathBounds(path);
        if (rect != null) {
          if (direction!=NO_MESSAGE && sender.equals(name))
            text = performative + " " + text;
          g.drawString(text, rect.x+rect.width+3, rect.y+rect.height-4);
        }
      }
    }

    /** 表示 */
    public void paint(Graphics g) {
      super.paint(g);
      g.setColor(Color.red);
      drawText(g);
      g.setColor(Color.blue);
      switch (direction) {
      case AGENT_TO_AGENT:  showAgentToAgent(g);  break;  // (1)
      case AGENT_TO_AGENTS: showAgentToAgents(g); break;  // (2)
      case AGENT_TO_ENV:    showAgentToEnv(g);    break;  // (3)
      case AGENT_TO_ACL:    showAgentToAgent(g);  break;  // (4)
      case   ENV_TO_AGENT:  showEnvToAgent(g);    break;  // (5)
      case   ENV_TO_AGENTS: showAgentToAgents(g); break;  // (6)
      case   ENV_TO_ACL:    showEnvToAgent(g);    break;  // (7)
      case   ACL_TO_AGENT:  showAgentToAgent(g);  break;  // (8)
      case   ACL_TO_AGENTS: showAgentToAgents(g); break;  // (9)
      case   ACL_TO_ENV:    showAgentToEnv(g);    break;  // (10)
      default: break;
      }
    }

    /** メッセージの矢印を表示するよう設定する */
    void showMsg(DashMessage m, String envname) {
      boolean fromACL = (m.from.equals(DashMessage.IF));
      boolean toACL = (m.to.equals(DashMessage.IF));
      boolean fromSomewhere =m.departure!=null && !envname.equals(m.departure);
      boolean toSomewhere   =m.arrival  !=null && !envname.equals(m.arrival);
      boolean broadcast = m.to.equals(DashMessage.BCAST);
      boolean fromDVM = (m.from.equals(DashMessage.DVM));
      boolean instantiate = (m.performative.equals(DashMessage.INSTANTIATE));
      boolean createInstance = (m.performative.equals(DashMessage.CREATEINSTANCE));

      // 送信者を決定してから、受信者を決定する。
      // 環境に関する判別を最優先にする。

      direction = ERROR;
      sender = receiver = null;
      if (fromSomewhere || fromDVM) {    // 他の環境あるいはDVMから！

        if (toSomewhere) {                 // (11)DVMから他のDVMへ！
          if (createInstance) {              // _createInstance
            direction = AGENT_TO_ENV;
            sender = m.getOtherAttributes(":target");
          } else
            direction = DVM_TO_DVM;          // no_such_agentなど
        } else if (toACL) {                // (7)ACLエディタへ！
          direction = ENV_TO_ACL;
          receiver = ACL_NODE_NAME;
        } else if (broadcast) {            // (6)全てのエージェントへ！
          direction = ENV_TO_AGENTS;
        } else if (instantiate) {          // _instantiate
          direction = ENV_TO_AGENT;
          receiver = m.getOtherAttributes(":target");
        } else {                           // (5)エージェントへ！
          direction = ENV_TO_AGENT;
          receiver = m.to;
        }

      } else if (fromACL) {             // ACLから！

        if (toSomewhere) {                 // (10)他の環境へ！
          direction = ACL_TO_ENV;
          sender = ACL_NODE_NAME;
        } else if (broadcast) {            // (9)全てのエージェントへ！
          direction = ACL_TO_AGENTS;
          sender = ACL_NODE_NAME;
        } else if (!toACL) {               // (8)エージェントへ！
          direction = ACL_TO_AGENT;
          sender = ACL_NODE_NAME;
          receiver = m.to;
        }

      } else {                          // この環境のエージェントから！

        if (toSomewhere) {                 // (3)他の環境へ！
          direction = AGENT_TO_ENV;
          sender = m.from;
        } else if (toACL) {                // (4)ACLへ！
          direction = AGENT_TO_ACL;
          sender = m.from;
          receiver = ACL_NODE_NAME;
        } else if (broadcast) {            // (2)全てのエージェントへ！
          direction = AGENT_TO_AGENTS;
          sender = m.from;
        } else {                           // (1)エージェントへ！
          direction = AGENT_TO_AGENT;
          sender = m.from;
          receiver = m.to;
        }
      }
      
      /* cout
      // 移動するときのcreate-instanceの:fromは
      // リポジトリエージェント名なのでワークプレースにはいない。
      // @see Workspace.moveProcess()
      if ((direction==AGENT_TO_ENV    ||        // (3)
           direction==AGENT_TO_ACL    ||        // (4)
           direction==AGENT_TO_AGENTS ||        // (2)
           direction==AGENT_TO_AGENT    ) &&    // (1)
          nodetable.get(sender)==null     &&
          m.dummyFrom!=null)
        sender = m.dummyFrom;
      */

      if (direction == ERROR) {
        // DASHのエラー。表示も同期処理もしない。
        dvm.printlnE("DashTree.showMsg(): 表示できないメッセージ:"+
                     m.toString2());

      } else if (direction == DVM_TO_DVM) {
        // エラー(no_sucn_agent)。表示も同期処理もしない。
        ; 

      } else {
        // 表示する。
        performative = m.performative;
        Runnable r = new Runnable() {
            public void run() {
              if (sender!=null)
                makeVisible(getPathByName(sender));
              if (receiver!=null)
                makeVisible(getPathByName(receiver));
              repaint();
            }};
        SwingUtilities.invokeLater(r);

        // 同期処理
        if (!nonStopCheck.isSelected()) {
          synchronized (stepButton) {
            stepButton.setEnabled(true);
            try { stepButton.wait(); } catch (InterruptedException e) { }
            stepButton.setEnabled(false);
          }
        } else
          try { Thread.sleep(200); } catch (InterruptedException e) { }
      }

      // 後始末
      direction = NO_MESSAGE;
      Runnable r = new Runnable() { public void run() { repaint(); }};
      SwingUtilities.invokeLater(r);
    }

    /** (1)AGENT_TO_AGENT
        (4)AGENT_TO_ACL
        (8)  ACL_TO_AGENT   */
    private void showAgentToAgent(Graphics g) {
      TreePath sPath = getPathByName(sender);
      TreePath rPath = getPathByName(receiver);

      if(!isVisible(sPath) || !isVisible(rPath)) 
        return; // 収納されている場合は描かない。

      int y1 = drawArrow(g, sender, true);
      int y2 = drawArrow(g, receiver, false);
      drawVLine(g, y1, y2);
    }

    /** (2)AGENT_TO_AGENTS
        (6)  ENV_TO_AGENTS
        (9)  ACL_TO_AGENTS  */
    private void showAgentToAgents(Graphics g) {
      TreePath path = null;
      for (Enumeration e = nodetable.keys(); e.hasMoreElements(); ) {
        path = getPathByName((String)e.nextElement());
        if (!isVisible(path))
          return;  // 1つでも収納されている場合は描かない。
      }

      int y, min, max;
      if (sender == null)
        min = max = drawEnvArrow(g, true);
      else if (sender.equals(ACL_NODE_NAME))
        min = max = drawArrow(g, sender, true);
      else {
        min = Integer.MAX_VALUE;
        max = Integer.MIN_VALUE;
      }
      for (Enumeration e = nodetable.keys(); e.hasMoreElements(); ) {
        String name = (String)e.nextElement();
        if (name.equals(sender))
          y = drawArrow(g, name, true);
        else
          y = drawArrow(g, name, false);
        min = (y<min) ? y : min;
        max = (y>max) ? y : max;
      }
      if (min!=Integer.MAX_VALUE)
        g.drawLine(5, min, 5, max);
    }

    /** (3)AGENT_TO_ENV
        (10) ACL_TO_ENV */
    private void showAgentToEnv(Graphics g) {
      TreePath path = getPathByName(sender);
      if (!isVisible(path))
        return; // 収納されている場合は描かない。

      int y1 = drawArrow(g, sender, true);
      int y2 = drawEnvArrow(g, false);
      drawVLine(g, y1, y2);
    }

    /** (5)ENV_TO_AGENT
        (7)ENV_TO_ACL    */
    private void showEnvToAgent(Graphics g) {
      TreePath path = getPathByName(receiver);
      if (!isVisible(path))
        return; // 収納されている場合は描かない。

      int y1 = drawArrow(g, receiver, false);
      int y2 = drawEnvArrow(g, true);
      drawVLine(g, y2, y1);
    }

    /**
     * nameで指定されたエージェントの水平矢印を描画する。
     * @param isSender trueの場合、右←左の矢印を描く。
     * @return 描けた場合はY座標、描けない場合は-1
     */
    private int drawArrow(Graphics g, String name, boolean isSender) {
      // pathは収納されていないことを確認してある。
      TreePath path = getPathByName(name);
      Rectangle rect = getPathBounds(path);
      int arrowX = rect.x - 2;
      int arrowY = rect.y + rect.height / 2;
      g.drawLine(arrowX, arrowY, 5, arrowY);
      if (isSender) {
        drawPerformative(g, rect);
        if (!name.equals(ACL_NODE_NAME)) {
          g.drawLine(7, arrowY, 10, arrowY-3);
          g.drawLine(7, arrowY, 10, arrowY+3);
        }
      } else {
        g.drawLine(arrowX, arrowY, arrowX-3, arrowY-3);
        g.drawLine(arrowX, arrowY, arrowX-3, arrowY+3);
      }
      return arrowY;
    }
    
    /**
     * envnameで指定された環境の垂直矢印を描画する。
     * @param isSender trueなら上から下へ描く。
     * @return Y座標
     */
    private int drawEnvArrow(Graphics g, boolean isSender) {
      DefaultTreeModel treeModel = (DefaultTreeModel)getModel();
      DefaultMutableTreeNode node =
        (DefaultMutableTreeNode)envtable.get(dvm.getDVMname());
      TreeNode nodes[] = treeModel.getPathToRoot(node);
      TreePath path = new TreePath(nodes);
      Rectangle rect = getPathBounds(path);
      int arrowX = 5;
      int arrowY = rect.y + rect.height + 1;
      if (isSender) {
        drawPerformative(g, rect);
      } else {
        g.drawLine(arrowX, arrowY, arrowX-3, arrowY+3);
        g.drawLine(arrowX, arrowY, arrowX+3, arrowY+3);
      }
      return arrowY;
    }


    /** y1からy2に垂直の線を引く */
    private void drawVLine(Graphics g, int y1, int y2) {
      g.drawLine(5, y1, 5, y2);
      int len = (y1>y2) ? y1-y2 : y2-y1;
      if (len > 30) {
        int yHead, yTail;
        if (y1<y2) {
          yHead = (y1+y2)/2 + 1; yTail = (y1+y2)/2 - 2;
        } else {
          yHead = (y1+y2)/2 - 2; yTail = (y1+y2)/2 + 1;
        }
        g.drawLine(5, yHead, 2, yTail);
        g.drawLine(5, yHead, 8, yTail);
      }
    }

    /** パフォーマティブと囲み線を描く */
    private void drawPerformative(Graphics g, Rectangle r) {
      g.drawRect(r.x-1, r.y, r.width+1, r.height);
      g.drawString(performative, r.x+r.width+3, r.y+r.height-4);
    }

    /** 指定された名前のエージェントノードorACLノードのパスを返す */
    private TreePath getPathByName(String name) {
      DefaultTreeModel treeModel = (DefaultTreeModel)getModel();
      DefaultMutableTreeNode node;
      if (name.equals(ACL_NODE_NAME))
        node = aclnode;
      else {
        node = (DefaultMutableTreeNode)nodetable.get(name);
      }      
      TreeNode nodes[] = treeModel.getPathToRoot(node);
      if (nodes == null)
        System.err.println("◆getPathByName: nullnode: "+name+"◆"+node+"◇"+nodetable);
      else if (nodes.length == 0)
        System.err.println("◆getPathByName: 0sizenode: "+name+"◆"+node+"◇"+nodetable);
      return new TreePath(nodes);
    }

  }

  /////////////////////////////////////////////////////////////////
  //  NoConsole関係  //////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////

  /**
   * プロパティadips97.noconsoleがonの場合、
   * 標準出力をallタブに、標準エラー出力をerrorタブに切替える。
   * Repository.main()から呼び出すと、
   * main()を実行していたスレッドが消滅したときにパイプが壊れる。
   */
  private void replaceConsole() {
    if (consoleReplace != null) return;

    String sw = System.getProperty("dash.noconsole");
    if (sw.equalsIgnoreCase("on")) {
      consoleReplace = new ConsoleReplace();
      usingConsoleReplace = true;
    }
  }

  private class ConsoleReplace {

    /** System.setOut(), System.setErr()するStream */
    private PrintStream stdoutPrintStream, stderrPrintStream;

    /** System.{out|err}.println()したバイト列を格納するStream*/
    ByteArrayOutputStream stdoutStream, stderrStream;

    /** コンストラクタ */
    ConsoleReplace() {
      stdoutStream = new ByteArrayOutputStream();
      stdoutPrintStream = new PrintStream(stdoutStream);
      System.setOut(stdoutPrintStream);

      stderrStream = new ByteArrayOutputStream();
      stderrPrintStream = new PrintStream(stderrStream);
      System.setErr(stderrPrintStream);
    }

    /** 表示 */
    void print() {
      synchronized (stdoutPrintStream) {
        if (stdoutStream.size()>0) {
          println(stdoutStream.toString());
          stdoutStream.reset();
        }
      }
      synchronized (stderrPrintStream) {
        if (stderrStream.size()>0) {
          printlnE(stderrStream.toString());
          stderrStream.reset();
        }
      }
    }

  }

}
